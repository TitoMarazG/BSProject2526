---
title: "BF"
author: "Leo"
date: "2025-12-03"
output: html_document
---

# FILE TUTTO IN UNO

## Skeleton

```{r skeleton}

```


## BF

In input alla funzione BF abbiamo:

- XX: Sum Squares of data
- n: numero di osservazioni
- a: parametro prior
- U: parametro prior
- u: parent del nodo da testare
- v: nodo da testare
- S: parents del nodo da testare senza l'arco entrante

```{r BF(XX, n, a, U, u, v, S)}
BF <- function(XX, n, a, U, u, v, S){
  return (exp(log.P_DAGM_puntuale(XX, n, a, U, v, S) - log.P_DAGM_puntuale(XX,n, a, U, v, c(S, u))))
}
```

## log.P_DAGM_puntuale(XX, n, a, U, nodo_da_testare, nodo_da_testare)

Versione di P_DAG_puntuale con matrice di adiacenza PDAGM:

- v è il nodo da testare nel DAGM
- S sono i parents del nodo da testare nel DAGM
- c(S, v) è la family del nodo da testare nel DAGM con l'arco entrante

```{r log.P_DAGM_puntuale(XX, n, a, U, nodo_da_testare, parents)}
log.P_DAGM_puntuale <- function(XX, n, a, U, v, S) {
  return(log.p_XA(XX, n, a, U, c(S, v)) - log.p_XA(XX, n, a, U, S))
}

```

## log.p(XA)

```{r log.p(XA)}
log.p_XA <- function(XX, n, a, U, A){
  nonA <- setdiff(1:ncol(XX), A)
  A.c <- length(A)  # cardinalità di A
  nonA.c <- length(nonA)  # cardinalità di nonA
  UAA <- U[A, A, drop = FALSE] #####
  XXAA <- XX[A, A, drop = FALSE]
  
  return(log(2*pi) * (-n*A.c/2)
         + log.norm_cost(a-nonA.c, UAA)
         - log.norm_cost(a+n-nonA.c, UAA+XXAA))
}
```

### log.norm_cost(a, U)

```{r}
log.norm_cost <- function(a, U){
  q = ncol(U)
  return(a/2*log(det(U))
         - a*q/2*log(2)
         - log.multivariate_gamma(q, a/2))
}
```

### log.multivariate_gamma(p, x)

```{r log.multivariate_gamma(p, x)}
log.multivariate_gamma <- function(p, x){
  val = 0
  for(j in 1:p)
    val = val + lgamma(x+(1-j)/2)
  return(p*(p-1)/4*log(pi)
         + val)
}
```
