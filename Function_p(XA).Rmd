---
title: "Function_p(XA)"
author: "Leo"
date: "2025-11-13"
output: html_document
---

# Computation of p(XA)

First: install the necessary package(s)

```{r setup, message=FALSE, warning=FALSE}
#install.packages("MCMCpack")
library(MCMCpack)
```

In this file I'm trying to build a script for the computation of p(XA)

The input are:

-   a: the value of the degrees of freedom,
-   U: the scale matrix,
-   X: the normal multivariate dataset,
-   A: a subset of the originale nodes/covariates set {1, ..., q}.

The output is:

-   p(XA): the marginal distribution of the subset of covariates contained in A.

Here I put the script provided from the Professor Castelletti and Professor Ferrini to create a **simulated normal multivariate dataset** of n=200, q=5 referred to a DAG D0:

```{r simulate normal multivariate dataset}
library(BCDAG)
q = 5 # number of nodes(/variables/covariates)
D0 = matrix(c(rep(0,q),
              rep(0, q),
              rep(c(1,1,0,0,0),3)), byrow = T, nrow = q, ncol = q) # adjacency matrix of a DAG
## Note: the true DAG is D1, i.e. the one having an edge u -> v
L = D0*matrix(runif(q*q, 1, 3), q, q)*
  sample(c(-1, 1), size = q*q, replace = TRUE)
diag(L) = 1
D = diag(rep(1, q)) # L and D are the parameters of the modified Cholesky decomposition of Sigma
Sigma = solve(t(L))%*%D%*%solve(L) # Sigma = (L')^-1 * D * (L)^-1
n = 200 # number of observations
X = mvtnorm::rmvnorm(n, rep(0, q), Sigma) # simulated data
print(D0)
head(X)
```

## Prior of Ω

Let's define the prior parameters a and U and then the prior of Ω

```{r Ω_prior}
a <- q # minimum df (a > q-1)
U <- diag(1, q) # minimum scale matrix: almost all zero
Ω_prior <- rWishart(100, a, U) # 100 matrices 5 x 5
```

## Posterior of Ω

We know that the Ω_posterior has

-   df = a + n
-   scale matrix = U + S, where S = X' * X

```{r Ω_posterior}
S = t(X)%*%X
Ω_posterior <- rWishart(100, a+n, U+S) # 100 matrices 5 x 5
```

We know that the Ω|X likelihood estimator is the ∑^-1 of X

```{r Ω_posterior_likelihood}
Ω_posterior_likelihood = solve(cov(X))
Ω_posterior_likelihood
```

## p(XA) metodo 1

Qui creo a parte una funzione che calcola la multivariate gamma function, la costante di normalizzazione c(a,U) e finalmente poi la p(XA)

### Multivariate gamma

```{r multivariate gamma function}

mvgamma_direct <- function(a, p) {
  term1 <- ((p * (p - 1)) / 4) *log(pi)
  j <- 1:p
  gamma_terms <- lgamma(a + (1 - j) / 2)
  term2 <- sum(gamma_terms)
  cat("Questo è term2 durante mvgamma: ", term2, "\n")
  cat("Questo è term1+term2 durante mvgamma: ", term1+term2, "\n")
  cat("Questo è exp(term1+term2) durante mvgamma: ", exp((term1 + term2)), "\n")

  return(exp((term1 + term2)))
}
```

### c(a, U)

```{r norm_cost}
norm_cost <- function(a, U){
  q = ncol(U)
  detU <- determinant(U, logarithm = FALSE)
  absdetU <- as.numeric(detU$modulus) # |U|
  num <- absdetU^(a / 2)               # |U|^(a/2)
  den <- 2^((a * q) / 2) * mvgamma_direct(a/2, q) # 2^(a*q/2) * Gamma_q(a/2)
  return (num/den)
}
```
 
Let's define the formula that gives back the distribution of p(XA)

```{r p_XA}
p_XA <- function(X, a, U, A){
  n = nrow(X)
  q = ncol(X)
  A <- sort(as.integer(A)) # per evitare errori in chiamate come X[, A] o S[A, A]
  card_A = length(A)
  card_nonA = q - card_A
  S = t(X) %*% X # S = X'X
  
  S_AA = S[A, A, drop = FALSE]
  U_AA = U[A, A, drop = FALSE]
  
  c_prior <- norm_cost(a - card_nonA, U_AA)
  c_post  <- norm_cost(a + n - card_nonA, U_AA + S_AA)
  
  
  factor = (2 * pi)^(- (n * card_A) / 2)
  p_val = factor * (c_prior / c_post)
  return(p_val) 
}
```

```{r}
X
a
U
A <- 1:3
p_XA(X, a, U, A)
```

## p(XA) metodo 2

Siccome trovo brutto e forse troppo costoso calcolare tutte quelle funzioni separatamente, ho provato a semplificare qualche termine ed è venuta fuori una formula più compatta. Potrebbe non essere efficace neanche queste perché c'è il pericolo che uno dei fattori esca troppo piccolo e R potrebbe approssimarlo a 0.
Di seguito lo script per il calcolo di p(X).
(ATTENZIONE, QUESTA SEMPLIFICAZIONE L'HO DIMOSTRATA SOLO PER n PARI, DEVO ANCORA VEDERE SE VALE PER n DISPARI)

```{r p(X)}
p_X <- function(a, U, n, S){
  q = ncol(U)
  val = pi^(-n*q/2) * ((det(U))^(a/2)) / (det(U+S)^((a+n)/2))
  n <- 5 # Definisci la tua variabile n
  cat("Questo è det(U)^(a/2) prima di cominciare a calcolare la produttoria: ", (det(U))^(a/2), "\n")
  cat("Questo è det(U+S)^((a+n)/2) prima di cominciare a calcolare la produttoria: ", (det(U+S)^((a+n)/2)), "\n")
  cat("Questo è p(X) prima di cominciare a calcolare la produttoria: ", val, "\n")
  for (jj in 1:q) {
    for (ii in 1:(n/2)) {
      val <- val * (a/2 + (1-jj)/2 + n/2 - ii)
    }
  }
  return(val)
}
```

```{r}
rapporto_norm_cost <- function(a, U, n, S){
  q = ncol(U)
  detU <- determinant(U, logarithm = FALSE)
  absdetU <- as.numeric(detU$modulus) # |U|
  B = U+S
  detB <- determinant(B, logarithm = FALSE)
  absdetB <- as.numeric(detB$modulus) # |B|
  num1 <- absdetU^(a / 2)               # |U|^(a/2)
  num2 <- absdetB^((a+n) / 2)               # |B|^((a+n)/2)
  den1 <- mvgamma_direct(a / 2, q)
  den2 <- mvgamma_direct((a+n) / 2, q)
  c1 <- num1/den1
  c2 <- num2/den2
  return(c1/c2/2^((n * q) / 2))
}
```


```{r}
a
U
n
S
rapporto_norm_cost(a,U,n,S)
p_X(a, U, n, S)
```
Infatti fa cagare che viene 0
