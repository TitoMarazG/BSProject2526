---
title: "Function_p(XA)"
author: "Leo"
date: "2025-11-13"
output: html_document
---

# Computation of p(XA)

First: install the necessary package(s)

```{r setup, message=FALSE, warning=FALSE}
#install.packages("MCMCpack")
library(MCMCpack)
```

In this file I'm trying to build a script for the computation of p(XA)

The input are:

-   a: the value of the degrees of freedom,
-   U: the scale matrix,
-   X: the normal multivariate dataset,
-   A: a subset of the originale nodes/covariates set {1, ..., q}.

The output is:

-   p(XA): the marginal distribution of the subset of covariates contained in A.

Here I put the script provided from the Professor Castelletti and Professor Ferrini to create a **simulated normal multivariate dataset** of n=200, q=5 referred to a DAG D0:

```{r simulate normal multivariate dataset}
library(BCDAG)
set.seed(100)
q = 5 # number of nodes(/variables/covariates)
D0 = matrix(c(rep(0,q),
              rep(0, q),
              rep(c(1,1,0,0,0),3)), byrow = T, nrow = q, ncol = q) # adjacency matrix of a DAG
## Note: the true DAG is D1, i.e. the one having an edge u -> v
L = D0*matrix(runif(q*q, 1, 3), q, q)*
  sample(c(-1, 1), size = q*q, replace = TRUE)
diag(L) = 1
D = diag(rep(1, q)) # L and D are the parameters of the modified Cholesky decomposition of Sigma
Sigma = solve(t(L))%*%D%*%solve(L) # Sigma = (L')^-1 * D * (L)^-1
n = 200 # number of observations
X = mvtnorm::rmvnorm(n, rep(0, q), Sigma) # simulated data
print(D0)
head(X)
```

## Prior of Ω

Let's define the prior parameters a and U and then the prior of Ω

```{r Ω_prior}
a <- q # minimum df (a > q-1)
U <- diag(1, q) # minimum scale matrix: almost all zero
Ω_prior <- rWishart(100, a, U) # 100 matrices 5 x 5
```

## Posterior of Ω

We know that the Ω_posterior has

-   df = a + n
-   scale matrix = U + S, where S = X' \* X

```{r Ω_posterior}
S = t(X)%*%X
Ω_posterior <- rWishart(100, a+n, U+S) # 100 matrices 5 x 5
```

We know that the Ω|X likelihood estimator is the ∑^-1 of X

```{r Ω_posterior_likelihood}
Ω_posterior_likelihood = solve(cov(X))
Ω_posterior_likelihood
```

## p(XA) metodo 1

Qui creo a parte una funzione che calcola la multivariate gamma function, la costante di normalizzazione c(a,U) e finalmente poi la p(XA). Siccome i numeri sono giganti, calcolo tutto in log e poi calcolo l'esponenziale. Nota per me stesso: in futuro sarebbe carino dare in pasto solo la prior anziché a ed U separati.

### p(XA)

```{r p(XA)}
p_XA <- function(S, n, a, U, A){
  return(exp(log.p_XA(S, n, a, U, A)))
}
```

### log(p(XA))

```{r}
log.p_XA <- function(S, n, a, U, A){
  nonA <- setdiff(1:ncol(X), A)
  A.c <- length(A)  # cardinalità di A
  nonA.c <- length(nonA)  # cardinalità di nonA
  UAA <- U[A, A, drop = FALSE] #####
  SAA <- S[A, A, drop = FALSE]
  
  return(log(2*pi) * (-n*A.c/2)
         + log.norm_cost(a-nonA.c, UAA)
         - log.norm_cost(a+n-nonA.c, UAA+SAA))
}
```

### log(c(a,U))

```{r}
log.norm_cost <- function(a, U){
  q = ncol(U)
  return(a/2*log(det(U))
         - a*q/2*log(2)
         - log.multivariate_gamma(q, a/2))
}
```

### log(Gamma_p(a))

```{r}
log.multivariate_gamma <- function(p, x){
  val = 0
  for(j in 1:p)
    val = val + lgamma(x+(1-j)/2)
  return(p*(p-1)/4*log(pi)
         + val)
}
```

### Proviamo a calcolare p(XA)

```{r}
head(X)
S = t(X)%*%X
S
a <- n
a
U <- diag(1, q)
U
A <- c(1,3,5)
A
```

```{r}
log.p_XA(S, n, a, U, A)
```

```{r}
p_XA(S, n, a, U, A)
```

Plot di log.p_XA in relazione ad a:

```{r}
a_vals <- 1:1000
y_di_a <- sapply(a_vals, function(val) 
                           log.p_XA(S, n, val, U, A)
                 )
plot(a_vals, y_di_a, 
     type = "l",        # "l" per una linea continua (più bello per le funzioni)
     ylim = c(-9000, 0), 
     xlab = "Gradi di libertà (a)", 
     ylab = "Log p(XA)",
     main = "Andamento di p(XA) al variare di a")
```

Massimo valore di **log(p(XA))**

```{r}
log.p_XA(S, n, q, U, A)
```

Massimo valore di **p(XA)** (exp(log(p(XA))))

```{r}
p_XA(S, n, q, U, A)
```

### Find a & U

Un metodo è quello di scegliere arbitrariamente a, U è quindi calcolata come l'inversa della sample covariance matrix scalata di un termine a.

Utilizzo la stima della media di Ω: E[Ω] ≈ a\*U Ω.cappuccio = ∑\^-1 (stima dai dati) =\> U = E[Ω]/a = ∑\^(-1)/a

```{r}
a = 100   # unica cosa che decido io
Sigma = cov(X)
Ω.cappuccio = solve(cov(X))
U = solve(cov(X))/a   # Ω.cappuccio/a
log.p_XA(S, n, a, U, A)
```

```{r}
a_vals <- q:100
lista_U <- lapply(a_vals, function(a) {
                            U <- (Ω.cappuccio / a)
                            return(U)}
                 )
log_probs <- rep(0, times = 100 - q)
for (i in 1:(100-q+1)) {
  log_probs[i] <- log.p_XA(S, n, a_vals[i], lista_U[[i]], A)
}
```

```{r}
plot(a_vals, log_probs, 
     type = "l",            # 'l' sta per linea
     col = "blue",          # Colore della linea
     lwd = 2,               # Spessore della linea
     main = expression(paste("Log Evidence vs ", a, " (con ", U == hat(Omega)/a, ")")),
     xlab = "Valore di a (Gradi di libertà)",
     ylab = "Log p(XA)")
grid()
max_idx <- which.max(log_probs)
best_a <- a_vals[max_idx]
abline(v = best_a, col = "red", lty = 2)
text(best_a, min(log_probs), paste("Max a =", best_a), pos = 4, col = "red")
```

Scelgo a minima, cioè q:

```{r}
a = 5
U = Ω.cappuccio/a
log.p_XA(S, n, a, U, A)
```

```{r}
p_XA(S, n, a, U, A)
```
