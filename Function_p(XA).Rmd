---
title: "Function_p(XA)"
author: "Leo"
date: "2025-11-13"
output: html_document
---

# Computation of p(XA)

First: install the necessary package(s)
```{r}
#install.packages("MCMCpack")
library(MCMCpack)
```


In this file I'm trying to build a script for the computation of p(XA)

The input are:

-   a: the value of the degrees of freedom,
-   U: the scale matrix,
-   X: the normal multivariate dataset,
-   A: a subset of the originale nodes/covariates set {1, ..., q}.

The output is:

-   p(XA): the marginal distribution of the subset of covariates contained in A.

Here I put the script provided from the Professor Castelletti and Professor Ferrini to create a **simulated normal multivariate dataset** of n=200, q=5 referred to a DAG D0:

```{r}
library(BCDAG)
q = 5 # number of nodes(/variables/covariates)
D0 = matrix(c(rep(0,q),
              rep(0, q),
              rep(c(1,1,0,0,0),3)), byrow = T, nrow = q, ncol = q) # adjacency matrix of a DAG
## Note: the true DAG is D1, i.e. the one having an edge u -> v
L = D0*matrix(runif(q*q, 1, 3), q, q)*
  sample(c(-1, 1), size = q*q, replace = TRUE)
diag(L) = 1
D = diag(rep(1, q)) # L and D are the parameters of the modified Cholesky decomposition of Sigma
Sigma = solve(t(L))%*%D%*%solve(L) # Sigma = (L')^-1 * D * (L)^-1
n = 200 # number of observations
X = mvtnorm::rmvnorm(n, rep(0, q), Sigma) # simulated data
print(D0)
head(X)
```

## Prior of Ω

Let's define the prior parameters a and U and then the prior of Ω

```{r}
a <- q # minimum df (a > q-1)
U <- diag(1e-06, q) # minimum scale matrix: almost all zero
Ω_prior <- rWishart(100, a, U) # 100 matrices 5 x 5
```

## Posterior of Ω

We know that the Ω_posterior has

-   df = a + n
-   scale matrix = U + S, where S = X' \* X

```{r}
S = t(X)%*%X
Ω_posterior <- rWishart(100, a+n, U+S) # 100 matrices 5 x 5
```

We know that the Ω\|X likelihood estimator is the ∑\^-1 of X

```{r}
Ω_posterior_likelihood = solve(cov(X))
Ω_posterior_likelihood
```
## p(XA)

### Multivariate gamma

```{r}
#' Calcola la Gamma Multivariata (Metodo Diretto, INSTABILE)
#'
#' @param a L'argomento della funzione
#' @param p La dimensione
#'
mvgamma_direct <- function(a, p) {
  
  # Termine 1: pi^(p*(p-1)/4)
  term1 <- pi^((p * (p - 1)) / 4)
  
  # Termine 2: La produttoria
  j <- 1:p
  
  # Calcoliamo i singoli valori gamma
  # es: [gamma(a + 0/2), gamma(a - 1/2), gamma(a - 2/2), ...]
  gamma_terms <- gamma(a + (1 - j) / 2)

  # Moltiplichiamo tutti i termini insieme
  # ATTENZIONE: Questo è il punto in cui fallisce!
  term2 <- prod(gamma_terms)
  
  # Risultato finale
  return(term1 * term2)
}
```


### c(a, U)

```{r}
norm_cost <- function(a, U){
  q = ncol(U)
  detU <- determinant(U, logarithm = FALSE)
  absdetU <- as.numeric(detU$modulus) # |U|
  num <- absdetU^(a / 2)               # |U|^(a/2)
  den <- 2^((a * q) / 2) * mvgamma_direct(a / 2, q) # 2^(a*q/2) * Gamma_q(a/2)
  return (num/den)
}
```
 
Let's define the formula that gives back the distribution of p(XA)

```{r}
p_XA <- function(X, a, U, A){
  n = nrow(X)
  q = ncol(X)
  A <- sort(as.integer(A)) # per evitare errori in chiamate come X[, A] o S[A, A]
  card_A = length(A)
  card_nonA = q - card_A
  S = t(X) %*% X # S = X'X
  
  S_AA = S[A, A, drop = FALSE]
  U_AA = U[A, A, drop = FALSE]
  
  c_prior <- norm_cost(a - card_nonA, U_AA)
  c_post  <- norm_cost(a + n - card_nonA, U_AA + S_AA)
  
  
  factor = (2 * pi)^(- (n * card_A) / 2)
  p_val = factor * (c_prior / c_post)
  return(p_val) 
}
```
