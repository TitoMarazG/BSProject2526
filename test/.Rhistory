q = 5 # Number of nodes
q = 5 # Number of nodes
indepTest = gaussCItest
source("~/GitHub/BSProject2526/test/data_simulator.R", echo = TRUE)
source("~/GitHub/BSProject2526/test/main_simulation_1.R", echo = TRUE)
source("~/GitHub/BSProject2526/test/main_simulation_1.R", echo = TRUE)
source("~/GitHub/BSProject2526/test/main_simulation_1.R", echo = TRUE)
library(BiocGenerics)
source("~/GitHub/BSProject2526/test/main_simulation_1.R", echo = TRUE)
source("~/GitHub/BSProject2526/test/main_simulation_1.R", echo = TRUE)
source("~/GitHub/BSProject2526/test/main_simulation_1.R", echo = TRUE)
source("~/GitHub/BSProject2526/test/main_simulation_1.R", echo = TRUE)
source("~/.active-rstudio-document", echo = TRUE)
install.packages("varbvs")
#install.packages("hdi")
install.packages("varbvs")
data(riboflavin)
help(data("riboflavin"))
source("~/.active-rstudio-document", echo = TRUE)
source("~/.active-rstudio-document", echo = TRUE)
source("~/.active-rstudio-document", echo = TRUE)
source("~/.active-rstudio-document", echo = TRUE)
dim(X_red)
sel_pip
# Selezione delle covariate con posterior probability più alta di 0.5, oppure, se queste ultime sono poche, teniamo le prime 200
sel_pip <- names(pip)[pip > 0.4]          # soglia "mediana" classica
sel_pip
# Selezione delle covariate con posterior probability più alta di 0.5, oppure, se queste ultime sono poche, teniamo le prime 200
sel_pip <- names(pip)[pip > 0.3]          # soglia "mediana" classica
sel_pip
source("~/.active-rstudio-document", echo = TRUE)
sel_pip
pip
sel_pip
install.packages("rstanarm")
source("~/.active-rstudio-document", echo = TRUE)
source("~/.active-rstudio-document", echo = TRUE)
source("~/.active-rstudio-document", echo = TRUE)
B <- post[, !colnames(post) %in% c("(Intercept)", "sigma"), drop = FALSE]
# P(|beta| > eps | y): probabilità a posteriori che coeff di regressione sia “sufficientemente lontano da 0”
eps <- 0.1  # in scala standardizzata: 0.1 è un effetto "piccolo ma reale"
p_big <- colMeans(abs(B) > eps) # media per colonna dei TRUE/FALSE (1/0): circa probabilità a posteriori che beta sia > soglia
# Selezione:
selected <- names(sort(p_big, decreasing = TRUE))[1:50]
X_red <- Xsc[, selected, drop = FALSE]
X_red <- X[, selected, drop = FALSE]
post <- as.matrix(fit_hs)  # Righe = campioni MCMC (tutte le chain concatenate); Colonne = coefficienti dei predittori
# nomi predittori così come sono in Xsc
x_names <- colnames(Xsc)
# quali coefficienti sono effettivamente presenti in post (Stan può droppare colonne)
present <- intersect(x_names, colnames(post))
if (length(present) == 0) stop("Nessun coefficiente di X trovato in 'post'")
post
x_names
colnames(post)
B <- post[, !colnames(post) %in% c("(Intercept)", "sigma"), drop = FALSE]
B
p_big
selected
# ora questa riga non può più fallire
X_red <- post[, selected, drop = FALSE]
X_red <- post[, selected, drop = FALSE]
X_red
selected
X_red <- as.matrix(df[, selected, drop = FALSE])
post <- as.matrix(fit_hs)  # Righe = campioni MCMC (tutte le chain concatenate); Colonne = coefficienti dei predittori
B <- post[, !colnames(post) %in% c("(Intercept)", "sigma"), drop = FALSE]
B_names <- colnames(B)
# rimuovi il prefisso X_red
B_names_new <- sub("^X_red", "", B_names)
colnames(B) <- B_names_new
# P(|beta| > eps | y): probabilità a posteriori che coeff di regressione sia “sufficientemente lontano da 0”
eps <- 0.1  # in scala standardizzata: 0.1 è un effetto "piccolo ma reale"
p_big <- colMeans(abs(B) > eps) # media per colonna dei TRUE/FALSE (1/0): circa probabilità a posteriori che beta sia > soglia
# Selezione:
selected <- names(sort(p_big, decreasing = TRUE))[1:50]
X_red <- Xsc[, selected, drop = FALSE] # il problema è che mi si sono sballati tutti i nomi delle colonne dopo aver usato STAN che quindi non coincidono più con quelli di Xsc (all'inizio del nome ha aggiunto X_red)
X_red
selected
X
